/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:36:55 2011
//--
//-- Source file: dma_core_axim_rdata.v
//---------------------------------------------------------



module dma_axi64_core0_axim_rdata(clk,reset,joint_stall,ch_fifo_wr,ch_fifo_wdata,ch_fifo_wsize,ch_fifo_wr_num,rd_transfer_num,rd_transfer,rd_transfer_size,rd_burst_cmd,load_wr,load_wr_num,load_wr_cycle,load_wdata,rd_clr_line,rd_clr_line_num,ARVALID,ARREADY,ARID,RID,RDATA,RLAST,RVALID,RREADY,RREADY_out);
   
   input               clk;
   input               reset;

   input               joint_stall;
   
   output               ch_fifo_wr;
   output [64-1:0]     ch_fifo_wdata;
   output [4-1:0]     ch_fifo_wsize;
   output [2:0]           ch_fifo_wr_num;
   output [2:0]           rd_transfer_num;
   output               rd_transfer;
   input [4-1:0]      rd_transfer_size;
   output               rd_burst_cmd;
   output               load_wr;
   output [2:0]           load_wr_num;
   output [1:0]           load_wr_cycle;
   output [64-1:0]     load_wdata;
   output               rd_clr_line;
   output [2:0]           rd_clr_line_num;

   input               ARVALID;
   input               ARREADY;
   input [`CMD_BITS-1:0]      ARID;
   input [`CMD_BITS-1:0]      RID;
   input [64-1:0]      RDATA;
   input               RLAST;
   input               RVALID;
   input               RREADY; 
   output               RREADY_out;
   

   reg [1:0]               load_wr_cycle;
   wire               load_cmd_id;
   wire               rd_clr_line_pre;
   wire               rd_clr_line_pre_d;
   reg [2:0]               ch_fifo_wr_num_d;
   reg [2:0]               rd_clr_line_num;
 



   
   assign               load_cmd_id     = RID[3];

   assign               RREADY_out      = (~rd_clr_line_pre) & (~rd_clr_line_pre_d) & (~joint_stall);

   assign               rd_transfer_num = RID[2:0];
   
   assign               rd_transfer     = RVALID & RREADY & (~load_cmd_id);
   
   assign               rd_burst_cmd    = rd_transfer & RID[5];

   assign               ch_fifo_wr      = rd_transfer;
      
   assign               ch_fifo_wdata   = RDATA;

   assign               ch_fifo_wsize   = rd_transfer_size;

   assign               ch_fifo_wr_num  = RID[2:0];
 

   assign               rd_clr_line_pre = RVALID & RREADY & RLAST & RID[6] & (~RID[3]);

   prgen_delay #(1) delay_clr(.clk(clk), .reset(reset), .din(rd_clr_line_pre), .dout(rd_clr_line_pre_d));
   prgen_delay #(1) delay_clr2(.clk(clk), .reset(reset), .din(rd_clr_line_pre_d), .dout(rd_clr_line));
   
   always @(posedge clk or posedge reset)
     if (reset)
       ch_fifo_wr_num_d <= #1 3'b000;
     else if (rd_clr_line_pre)
       ch_fifo_wr_num_d <= #1 ch_fifo_wr_num;

   always @(posedge clk or posedge reset)
     if (reset)
       rd_clr_line_num <= #1 3'b000;
     else if (rd_clr_line_pre_d)
       rd_clr_line_num <= #1 ch_fifo_wr_num_d;
   
   assign               load_wr         = RVALID & RREADY & load_cmd_id;

   assign               load_wr_num     = RID[2:0];
   
   assign               load_wdata      = RDATA;
   
   
   always @(posedge clk or posedge reset)
     if (reset)
       load_wr_cycle <= #1 2'b00;
     else if (load_wr & load_wr_cycle[0] & 1'b1)
       load_wr_cycle <= #1 2'b00;
     else if (load_wr)
       load_wr_cycle <= #1 load_wr_cycle + 1'b1;


   
   
endmodule

   



