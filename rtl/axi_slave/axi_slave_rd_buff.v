//------------------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- RobustVerilog version 1.2 (limited free version)
//-- Invoked Sun Mar 24 15:39:38 2019
//-- Source file: axi_slave_rd_buff.v
//-- Parent file: axi_slave_ram.v
//-- Run directory: E:/vlsi/axi_slave/run/
//-- Target directory: out/
//-- Command flags: ../src/base/axi_slave.v -od out -I ../src/gen -list list.txt -listpath -header -gui 
//-- www.provartec.com/edatools ... info@provartec.com
//------------------------------------------------------------------






module axi_slave_rd_buff(clk,reset,RD,DOUT,rcmd_len,rcmd_len2,rcmd_resp,rcmd_timeout,rcmd_ready,RVALID,RREADY,RLAST,RDATA,RRESP,RD_last,RBUSY);

   input               clk;
   input               reset;

   output               RD;
   input [64-1:0]      DOUT;
   
   input [4-1:0]       rcmd_len;
   input [4-1:0]       rcmd_len2;
   input [1:0]               rcmd_resp;
   input               rcmd_timeout;
   input               rcmd_ready;

   output               RVALID;
   input               RREADY;
   output               RLAST;
   output [64-1:0]     RDATA;
   output [1:0]           RRESP;
   output               RD_last;

   input               RBUSY;
   
   

   reg [4:0]           valid_counter;
   reg [4-1:0]           rd_counter;
   wire               cmd_pending;
   reg                   RVALID;
   reg [1:0]               RRESP;
   wire               last_rd;
   
   
   assign               cmd_pending = RVALID & (~RREADY);
   
   assign               RDATA   = DOUT;

   
   assign               RD      = rcmd_ready & (~cmd_pending) & (~RBUSY) & (~rcmd_timeout);

   assign               RD_last = RD & (rd_counter == rcmd_len);
   
   assign               RLAST   = RVALID & (valid_counter == rcmd_len2 + 1'b1);


   
   always @(posedge clk or posedge reset)
     if (reset)
       RRESP <= #1 2'b00;
     else if (RD)
       RRESP <= #1 rcmd_resp;
   
   always @(posedge clk or posedge reset)
     if (reset)
       RVALID <= #1 1'b0;
     else if (RD)
       RVALID <= #1 1'b1;
     else if (RVALID & RREADY)
       RVALID <= #1 1'b0;
   
   
   always @(posedge clk or posedge reset)
     if (reset)
       valid_counter <= #1 {4+1{1'b0}};
     else if (RVALID & RREADY & RLAST & RD)
       valid_counter <= #1 'd1;
     else if (RVALID & RREADY & RLAST)
       valid_counter <= #1 {4+1{1'b0}};
     else if (RD)
       valid_counter <= #1 valid_counter + 1'b1;

   always @(posedge clk or posedge reset)
     if (reset)
       rd_counter <= #1 {4{1'b0}};
     else if (RD_last)
       rd_counter <= #1 {4{1'b0}};
     else if (RD)
       rd_counter <= #1 rd_counter + 1'b1;

   
endmodule

   


