//------------------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- RobustVerilog version 1.2 (limited free version)
//-- Invoked Sun Mar 24 15:39:38 2019
//-- Source file: axi_slave_busy.v
//-- Parent file: axi_slave_ram.v
//-- Run directory: E:/vlsi/axi_slave/run/
//-- Target directory: out/
//-- Command flags: ../src/base/axi_slave.v -od out -I ../src/gen -list list.txt -listpath -header -gui 
//-- www.provartec.com/edatools ... info@provartec.com
//------------------------------------------------------------------





  
module axi_slave_busy(clk,reset,ARBUSY,RBUSY,AWBUSY,WBUSY,BBUSY);
   
   
   input               clk;
   input               reset;
   
   output               ARBUSY;
   output               RBUSY;
   output               AWBUSY;
   output               WBUSY;
   output               BBUSY;


   reg                        stall_enable    = 1;
      
   integer                    burst_chance    = 1;
   integer               burst_len       = 10;
   integer               burst_val       = 90;
   
   integer               ar_stall_chance = 10;
   integer               r_stall_chance  = 10;
   integer               aw_stall_chance = 10;
   integer               w_stall_chance  = 10;
   integer               b_stall_chance  = 10;

   
   integer               burst_type;
   reg                   burst_stall;
   integer               ar_stall_chance_valid;
   integer               r_stall_chance_valid;
   integer               aw_stall_chance_valid;
   integer               w_stall_chance_valid;
   integer               b_stall_chance_valid;
   
   
   reg                   ARBUSY_pre = 0;
   reg                   RBUSY_pre = 0;
   reg                   AWBUSY_pre = 0;
   reg                   WBUSY_pre = 0;
   reg                   BBUSY_pre = 0;
   reg                   ARBUSY;
   reg                   RBUSY;
   reg                   AWBUSY;
   reg                   WBUSY;
   reg                   BBUSY;


   task set_stall;
      reg stall;
      begin
         ar_stall_chance_valid = ar_stall_chance;
         r_stall_chance_valid  = r_stall_chance;
         aw_stall_chance_valid = aw_stall_chance;
         w_stall_chance_valid  = w_stall_chance;
         b_stall_chance_valid  = b_stall_chance;
      end
   endtask

   initial
     begin
    #1;
    set_stall;

    if (burst_chance > 0)
      forever
        begin
           burst_stall = rand_chance(burst_chance);
           
           if (burst_stall)
         begin
            #1;
            burst_type = rand_f(1, 5);
            
            case (burst_type)
              1 : ar_stall_chance_valid = burst_val;
              2 : r_stall_chance_valid  = burst_val;
              3 : aw_stall_chance_valid = burst_val;
              4 : w_stall_chance_valid  = burst_val;
              5 : b_stall_chance_valid  = burst_val;
            endcase
            
            repeat (burst_len) @(posedge clk);
            set_stall;
         end
           else
         begin
            @(posedge clk);
         end
        end
     end
   
   always @(posedge clk)
     begin
    #1;
    ARBUSY_pre = rand_chance(ar_stall_chance_valid);
        RBUSY_pre  = rand_chance(r_stall_chance_valid);
        AWBUSY_pre = rand_chance(aw_stall_chance_valid);
        WBUSY_pre  = rand_chance(w_stall_chance_valid);
        BBUSY_pre  = rand_chance(b_stall_chance_valid);
     end
   
   always @(posedge clk or posedge reset)
     if (reset)
       begin
          ARBUSY <= #1 1'b0;
          RBUSY  <= #1 1'b0;
          AWBUSY <= #1 1'b0;
          WBUSY  <= #1 1'b0;
          BBUSY  <= #1 1'b0;
       end
     else if (stall_enable)
       begin
          ARBUSY <= #1 ARBUSY_pre;
          RBUSY  <= #1 RBUSY_pre;
          AWBUSY <= #1 AWBUSY_pre;
          WBUSY  <= #1 WBUSY_pre;
          BBUSY  <= #1 BBUSY_pre;
       end
     else
       begin
          ARBUSY <= #1 1'b0;
          RBUSY  <= #1 1'b0;
          AWBUSY <= #1 1'b0;
          WBUSY  <= #1 1'b0;
          BBUSY  <= #1 1'b0;
       end
   
endmodule
   









