/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:36:57 2011
//--
//-- Source file: dma_ch_rd_slicer.v
//---------------------------------------------------------


  

module  dma_axi64_core0_ch_rd_slicer (clk,reset,fifo_rd,fifo_rdata,fifo_rsize,rd_align,rd_ptr,rd_line_remain,wr_incr,wr_single,slice_rd,slice_rdata,slice_rsize,slice_rd_ptr,slice_rd_valid);

   input               clk;
   input               reset;

   input               fifo_rd;
   input [64-1:0]      fifo_rdata;
   input [4-1:0]      fifo_rsize;
   input [3-1:0]      rd_align;
   input [5-1:0]      rd_ptr;
   input [4-1:0]      rd_line_remain;
   input               wr_incr;
   input               wr_single;
   
   output               slice_rd;
   output [64-1:0]     slice_rdata;
   output [4-1:0]     slice_rsize;
   output [5-1:0]     slice_rd_ptr;
   output               slice_rd_valid;
   
   
   
   wire               slice_rd_pre;
   wire               slice_rd;
   wire [5-1:0]       slice_rd_ptr;
   reg [64-1:0]           slice_rdata;
   wire [4-1:0]       slice_rsize;

   wire               fifo_rd_d;
   wire               slice_rd_d;
   wire [3-1:0]       rd_align_valid_pre;
   reg [3-1:0]           rd_align_valid;
   reg [3-1:0]           rd_align_d;
   
   reg [64-1:0]           next_rdata_pre;
   reg [64-1:0]           next_rdata;
   
   reg [4-1:0]           actual_rsize;
   wire [4-1:0]       actual_rsize_pre;
   reg [4-1:0]           next_rsize_reg;
   wire [4-1:0]       next_rsize;
   wire               next_rd;
   
   
   //RDATA
   prgen_delay #(1) delay_fifo_rd0    (.clk(clk), .reset(reset), .din(fifo_rd), .dout(fifo_rd_d));
   prgen_delay #(2) delay_fifo_rd_valid (.clk(clk), .reset(reset), .din(fifo_rd_d), .dout(slice_rd_valid));
   prgen_delay #(1) delay_fifo_rd1    (.clk(clk), .reset(reset), .din(slice_rd_pre), .dout(slice_rd));
   prgen_delay #(1) delay_fifo_rd2    (.clk(clk), .reset(reset), .din(slice_rd), .dout(slice_rd_d));
   

   assign               rd_align_valid_pre = 
                  (~wr_incr) & wr_single ? rd_align - rd_ptr[3-1:0] :
                  rd_align;
   
   
   always @(posedge clk or posedge reset)
     if (reset)
       begin
      rd_align_valid <= #1 {3{1'b0}};
      rd_align_d     <= #1 {3{1'b0}};
       end
     else
       begin
      rd_align_valid <= #1 rd_align_valid_pre;
      rd_align_d     <= #1 rd_align_valid;
       end
   
   always @(/*AUTOSENSE*/fifo_rdata or next_rdata or rd_align_d)
     begin
    case(rd_align_d[3-1:0])
      3'd0 : slice_rdata = next_rdata[63:0];
      3'd1 : slice_rdata = {fifo_rdata[55:0], next_rdata[7:0]};
      3'd2 : slice_rdata = {fifo_rdata[47:0], next_rdata[15:0]};
      3'd3 : slice_rdata = {fifo_rdata[39:0], next_rdata[23:0]};
      3'd4 : slice_rdata = {fifo_rdata[31:0], next_rdata[31:0]};
      3'd5 : slice_rdata = {fifo_rdata[23:0], next_rdata[39:0]};
      3'd6 : slice_rdata = {fifo_rdata[15:0], next_rdata[47:0]};
      3'd7 : slice_rdata = {fifo_rdata[7:0],  next_rdata[55:0]};
    endcase
     end
   

   always @(/*AUTOSENSE*/fifo_rdata or rd_align_valid)
     begin
    case(rd_align_valid[3-1:0])
      3'd0 : next_rdata_pre = fifo_rdata[63:0];
      3'd1 : next_rdata_pre = {{56{1'b0}}, fifo_rdata[63:56]};
      3'd2 : next_rdata_pre = {{48{1'b0}}, fifo_rdata[63:48]};
      3'd3 : next_rdata_pre = {{40{1'b0}}, fifo_rdata[63:40]};
      3'd4 : next_rdata_pre = {{32{1'b0}}, fifo_rdata[63:32]};
      3'd5 : next_rdata_pre = {{24{1'b0}}, fifo_rdata[63:24]};
      3'd6 : next_rdata_pre = {{16{1'b0}}, fifo_rdata[63:16]};
      3'd7 : next_rdata_pre = {{8{1'b0}},  fifo_rdata[63:8]};
    endcase
     end

   
   
   always @(posedge clk or posedge reset)
     if (reset)
       next_rdata <= #1 {64{1'b0}};
     else if (slice_rd_d)
       next_rdata <= #1 next_rdata_pre;
   
   
   //RSIZE
   assign actual_rsize_pre    = next_rsize + ({4{fifo_rd}} & fifo_rsize);

   always @(posedge clk or posedge reset)
     if (reset)
       actual_rsize <= #1 {4{1'b0}};
     else if (fifo_rd | (|next_rsize))
       actual_rsize <= #1 actual_rsize_pre;
   
   prgen_min2 #(4) min_rsize(
                   .a(rd_line_remain),
                   .b(actual_rsize),
                   .min(slice_rsize)
                   );
   

   always @(posedge clk or posedge reset)
     if (reset)
       next_rsize_reg <= #1 {4{1'b0}};
     else if (next_rd)
       next_rsize_reg <= #1 {4{1'b0}};
     else if (fifo_rd | slice_rd)
       next_rsize_reg <= #1 next_rsize + ({4{fifo_rd}} & fifo_rsize);

   assign next_rsize = next_rsize_reg - ({4{fifo_rd_d}} & slice_rsize);
   
   //CMD
   assign next_rd         = (~fifo_rd) & (|next_rsize);  
   
   assign slice_rd_pre    = fifo_rd | next_rd;

   assign slice_rd_ptr    = rd_ptr;
   
 
endmodule



   


